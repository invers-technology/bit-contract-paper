\section{Formalization}
本章の目的は、Bitcoin を $U$ を状態、$tx$ を遷移とするステートマシンとして再定式化し、その上でスマートコントラクトを (1) 資産の拘束（lock）(2) 解放条件（unlock predicate）(3) 条件成立時に許される出力（prescribed transition / template）として形式的に定義することである。

本稿は 汎用 VM による任意計算と広範な mutable global state、すなわち共有可変ストレージを採用しない。
代わりに、コントラクトは テンプレート（template）として事前に制約され、インスタンス化はテンプレート参照と引数によって与えられる。
共有される状態は $\mathsf{stateTag}$ に限定し、テンプレートが定める有限ラベルとしてグローバルに解釈される唯一の状態語彙とする。
必要であれば $\Gamma$ や参照情報は immutable global registryとして保持し得る。
これは不変レジストリであり、R4 に整合する。

本章は「一般形式（general form）」までを与え、ユースケース適用は次章でテンプレート群（deposit/release/refund）として具体化する。

\subsection{Notation and Conventions}
$\parallel$ は連結（concatenation）を表し、$H(\cdot)$ は暗号学的ハッシュ関数を表す。
記号の使い分けとして、$\mathsf{index}$ はインクリメントされる自然数の添字（例：outpoint の $i$、テンプレート参照の $\mathsf{t}_{index}$）を指し、$\mathsf{id}$ はハッシュ関数等で導出される識別子（例：$\mathsf{tx}_{id}, \mathsf{c}_{id}$）を指す。
$\mathsf{PK}$ は公開鍵集合であり、$\mathsf{pk} \in \mathsf{PK}$ は、公開鍵である。

\subsection{UTXO ステートマシン}
本節は Bitcoin の Script や補助入力構造を忠実に再現しない。
$U$ と遷移として抽象化し、テンプレート参照・状態タグ・検証述語・出力仕様に必要な最小要素のみを定義する。
署名検証等の基礎規則は抽象述語 $\mathsf{BaseValid}$ にまとめる。
\paragraph{Definition 1：UTXO と Outpoint}
Outpoint を $\mathsf{op}=(\mathsf{tx}_{id}, i)$ とし、UTXO を $u$ で次のように表す：
\begin{equation}
	u=(\mathsf{op}, v, \mathsf{pk})
\end{equation}
\begin{equation}
	u^\star=(\mathsf{op}, v, \mathsf{pk}, \mathsf{c}_{id}, \mathsf{stateTag})
\end{equation}
ここで $v$ は額面、$\mathsf{pk}$ は所有者（支出権限）を表す公開鍵、$u$ は通常の UTXO である。
テンプレート参照と状態タグを伴うロック状態の UTXO を \textbf{Locked UTXO} と呼び、$u^\star$ と記す。
\textbf{実装上は、$(\mathsf{c}_{id}, \mathsf{stateTag})$ は $tx$ の $\mathsf{aux}$ に埋め込まれ得る抽象化であり、$u$ に独立のフィールドがあることを仮定しない。
}
（Bitcoin Script 相当では $(\mathsf{c}_{id}, \mathsf{stateTag})$ を script/commitment/metadata として埋め込める。
eUTXO では datum として扱える。）

\paragraph{Definition 2：台帳状態}
$\Sigma$ を
\begin{equation}
	\Sigma := (U, \Gamma)
\end{equation}
とする。
$U$ は未消費 UTXO の集合、$\Gamma$ はテンプレート集合（および必要な参照情報）から成る不変レジストリである（R4）。

\paragraph{Definition 3：$tx$}
$tx$ を
\begin{equation}
	tx := (\mathsf{in}, \mathsf{out}, \mathsf{aux})
\end{equation}
とする。
$\mathsf{in}$ は入力 outpoint 列 $\mathsf{in}:=[\mathsf{op}_j]$、$\mathsf{out}$ は出力 $u$ 列、$\mathsf{aux}$ は署名・期限情報など検証に必要な補助入力である。
Bitcoinと同様に、本稿の $tx$ は from/to アドレスを明示的なフィールドとして含まない。
本稿で $\mathsf{pk}_{\mathrm{from}}$ と記す場合は、入力 $u$ の所有者（消費権限の主体）を指す略記であり、明示フィールドではなく入力の検証から同定される。

\paragraph{Contract Transaction 共通ヘッダ（aux）}
本稿で扱う Contract Transaction の $\mathsf{aux}$ は canonical encoding された byte 列とし、少なくとも\texttt{proto\_version}、\texttt{tx\_type} $\in \{\mathrm{CREATE},\mathrm{LOCK},\mathrm{EXECUTE},\mathrm{FINALIZE}\}$、\texttt{cid}、\texttt{payload\_bytes}を含む。
ここで \texttt{payload\_bytes} は型固有データである。
合意・検証・$\mathsf{c}_{id}$ 導出に用いるのは必ずシリアライズ済み byte[]（例：\texttt{init\_params\_bytes}）であり、JSON などの文字列表現は表示・ログ用途の非合意データに限る。
\texttt{tx\_type} を合意対象として固定するのは、型の曖昧解釈を排除し、安価な分類で DoS 耐性を高め、\texttt{proto\_version}/\texttt{payload\_bytes} により将来拡張を可能にするためである。
$\mathsf{aux}$ は合意対象データ（consensus-critical bytes）であり、Contract Transaction の wire-level encoding は TLV（Type-Length-Value）として規範化する。
すなわち、$\mathsf{aux}$ 内の \texttt{proto\_version}/\texttt{tx\_type}/\texttt{payload\_bytes}は canonical TLV bytes として一意に解釈される。
Ethereum の Typed Transaction Envelope と同様に型情報を明示しつつ（括弧内での言及に留める）、Bitcoin の raw $tx$ が byte 列として合意対象であることと同じく、合意に用いる入力は canonical TLV bytes に固定される。
規範仕様は次のとおりである。
\begin{itemize}
	\item Type：u16 の big-endian
	\item Length：unsigned LEB128 varint（最短表現のみ許容。非canonical表現は invalid）
	\item Value：raw bytes
	\item 要素順序：Type 昇順でソート
	\item 重複 Type：禁止（duplicate type は invalid）
	\item 未知 Type：$u^\star$ を入力に含む $tx$ では unknown type を invalid とし、それ以外は将来拡張のために skip 可とする
\end{itemize}
固定長整数の値表現は big-endian とする。
$c_{id}$/署名/検証の合意対象は canonical TLV bytes であり、例として \texttt{init\_params\_bytes} は canonical TLV bytes として扱う。
TLV の type 割当はプロトコル定数であり、Appendix に test vectors を示す。

\paragraph{Definition 4：基礎検証：UTXO 妥当性}
$tx$ が $\Sigma$ 上で基礎的に妥当であるとは、$\mathsf{BaseValid}(\Sigma, tx)=\mathsf{true}$ を満たすことをいう。
$\mathsf{BaseValid}$ は入力参照の健全性・二重消費排除・署名等による消費権限検証・価値保存/手数料規則を含む抽象述語であり、例えば次を含む。
\begin{enumerate}
	\item[(i)] 入力が $U$ の要素を参照し、二重消費がない。
	\item[(ii)] 署名等により消費権限が検証できる。
	\item[(iii)] 価値保存（$\sum v_{\mathrm{in}}=\sum v_{\mathrm{out}}+\mathsf{fee}$）等のプロトコル規則を満たす。
\end{enumerate}

\paragraph{遷移規則（状態更新）}
$tx$ が $\mathsf{BaseValid}(\Sigma, tx)=\mathsf{true}$ を満たし、かつ admissible（Definition 10）であるとき、状態遷移
\begin{equation}
	\Sigma \xrightarrow{tx} \Sigma'
\end{equation}
を定義する。
ここで $U_{\mathrm{in}}(tx)$ は入力が参照する $u$ の集合、$U_{\mathrm{out}}(tx)$ は出力 $u$ の集合とし、
\begin{equation}
	U' := (U \setminus U_{\mathrm{in}}(tx)) \cup U_{\mathrm{out}}(tx), \quad \Gamma' := \Gamma
\end{equation}
として $\Sigma' := (U', \Gamma')$ を得る。

\subsection{スマートコントラクトの抽象定義：LockUtxo / Predicate / Prescribed Transition}
本稿は、スマートコントラクトを「汎用プログラム」ではなく、条件付き資産移転として抽象化する。

\paragraph{Definition 5：テンプレート型コントラクト}
テンプレート型スマートコントラクトを次の 3 つ組として定義する：
\begin{equation}
	C := (\mathsf{LockUtxo}, \mathsf{Pred}, \mathsf{Trans})
\end{equation}
\begin{itemize}
	\item $\mathsf{LockUtxo}$：資産を拘束する操作（どの形の $u$ を Locked 状態にするか）
	\item $\mathsf{Pred}$：解放条件（unlock predicate）。
	      外部裁量ではなく検証可能な述語である（R2）。
	\item $\mathsf{Trans}$：条件成立時に許される出力形（prescribed transition / template）。
	      出力が任意ではなく、テンプレートで上限付きに規定される（R3）。
\end{itemize}

\subsection{オンチェーン対象：Template / Contract Instance / $u^\star$}
本稿の対象を、“状態として何が増えるか”が明確になるように、次の 3 層に整理する。

\paragraph{Definition 6：Template：普遍}
テンプレート $\tau \in \Gamma$ は次の構造を持つ：
\begin{equation}
	\tau := (\mathsf{t}_{index}, \mathsf{InitParams}, \mathsf{LockParams}, \mathsf{StateSet}, \mathsf{LogicSet}, \mathsf{TransSpec})
\end{equation}
\begin{itemize}
	\item $\mathsf{t}_{index}$：テンプレート $\mathsf{t}_{index}$ は固定
	\item $\mathsf{InitParams}$：初期化引数スロット（型・制約）。
	      CreateContract の Constructor 引数により初期化され、以後は定数として更新されない。
	\item $\mathsf{LockParams}$：ロック引数スロット（型・制約）。
	      LockUtxo 時に与えられる引数を $\mathsf{InitParams}$ 同様に検証するために用いられる。
	\item $\mathsf{StateSet}$：テンプレートが取りうる有限の状態ラベル集合。
	      $s_{\mathrm{init}} \in \mathsf{StateSet}$ を初期状態とする。
	\item $\mathsf{LogicSet}$：検証ロジック（validator）の集合。
	      Key を $\mathsf{LogicIndex}$ $\ell$ とし、value は $\mathsf{func}_\ell$ を与える写像であり、$\mathsf{LogicSet}[\ell] = \mathsf{func}_\ell$ と書く。
	      各 $\mathsf{func}_\ell$ は $(\mathsf{args}_\ell, \mathsf{modifier}_\ell, \mathsf{post\_state}_\ell, \mathsf{validation}_\ell)$ から成り、$\mathsf{modifier}_\ell$ は現状態で当該関数を実行可能かを判定し、$\mathsf{validation}_\ell$ は $\mathsf{post\_state}_\ell$ と $\mathsf{args}_\ell$ を検証して遷移の妥当性を確認する。
	\item $\mathsf{TransSpec}$：状態と生成する $tx$ の形の二つから成る出力仕様
\end{itemize}
本稿ではテンプレート $\tau$ を記述する DSL として Computational Law DSL である Stipula を採用する。
Stipula は自然言語的な契約条項を $\mathsf{Pred}$ および各遷移に対応する $\mathsf{TransSpec}$ として形式化し、検証者が $tx$ を見て一意に判定できる決定的条件（R2）として与える。
また、テンプレート制約による監査上限（R3）を、実装規律ではなく仕様記述の表現力として固定できる点が Stipula 採用の理由である。
さらに、この制約は、利用者が署名時点で取引意味と遷移結果を点検できる（予測可能性を確保する）ための条件でもある。したがって本稿は、任意コードの汎用VM実装ではなく、テンプレートとして列挙可能な範囲に契約を閉じることを設計原理とする。
UTXO は実行モデル、Stipula はテンプレート仕様の記述層として位置づけられ、$\mathsf{stateTag}$ と不変レジストリ $\Gamma$ 以外の共有状態を増やさない。
$\Gamma$ は fixed protocol version $\mathsf{v}_{\mathrm{proto}}$ に対するコンセンサス定数であり、$\Sigma$ の通常遷移では変化しない。
$\Gamma$ の変更はアプリ層の差替えではなく、合意形成を伴うプロトコル更新としてのみ許容される（本稿は $\mathsf{v}_{\mathrm{proto}}$ を固定して安全性を論じる）。
$\tau \in \Gamma$ は「契約コード」ではなく 検証規則（consensus-verifiable predicate / transition specification）であるため、個別の作成者や当事者が任意に更新できない。
例外として、深刻な脆弱性や仕様誤りが見つかった場合の対応は、アプリ層のアップグレードではなく プロトコル更新（合意形成コストを伴う）として扱う。

\paragraph{Definition 7：Contract Instance：インスタンス記述子}
コントラクト・インスタンス $I$ は
\begin{equation}
	I := (\mathsf{c}_{id}, \mathsf{t}_{index}, \vec{a})
\end{equation}
で表す。
$\vec{a}=(a_1,\dots,a_k)$ は $\mathsf{InitParams}$ に対応する初期化引数列であり、CreateContract の Constructor 引数として $\mathsf{InitParams}$ を初期化し、以後は更新されない。
$\vec{a}$ は canonical TLV encoding された \texttt{init\_params\_bytes} のデコード結果であり、合意対象は byte 列そのものとする。
コントラクトインスタンスの内部変数（$\mathsf{InitParams}$）は、CreateContract によって生成された際から不変である。
$\mathsf{c}_{id}$ は決定的に導出される識別子であり、例えば
\begin{equation}
	\mathsf{c}_{id} := H(\mathsf{tx}_{id} \parallel \mathsf{pk}_{\mathrm{from}} \parallel \mathsf{t}_{index} \parallel \mathsf{init\_params\_bytes})
\end{equation}
のように作れる（重要なのは同一入力から一意であること）。
ここで $\mathsf{tx}_{id}$ は CreateContract $tx$ の ID、$\mathsf{pk}_{\mathrm{from}}$ は CreateContract/LockUtxo を作成する主体の \textbf{from（送信元）} 公開鍵（入力 $u$ の所有者公開鍵）である。
これにより「参照先インスタンスが曖昧」「後から差し替え」等の裁量余地を縮退する（R2, R3）。

\paragraph{Definition 8：$u^\star$：型付き状態}
$u^\star$ は、テンプレート参照と状態タグを伴う型付き状態である、という設計選好を仕様として固定する。
$u^\star$（Definition 1）において、$\mathsf{c}_{id}$ は参照先インスタンス、$\mathsf{stateTag}$ はテンプレートが定める有限個の状態ラベル（例：$S0, S0D, S0X$）であり、対応するテンプレート $\tau$ の $\mathsf{StateSet}_\tau$ に属する。
本稿では $\mathsf{stateTag}$ を共有される唯一のグローバルステートとして扱う。
実装上の埋め込みは Definition 1 の注記に同じであり、独立の状態欄を仮定しない。
これにより「条件を script 断片に依存させる」から、「状態タグとテンプレート参照により検証する」へと、監査可能性が上限付きの表現に移る。

\subsection{遷移規則：CreateContract / LockUtxo / Release / FinalizeContract と Admissibility}
本節では、$u^\star$ を生成・消費する遷移の妥当性を admissibility、すなわち許容条件として定義する。
要件は「外部裁量ではなく検証可能」＝決定的 admissibility である（R2）。

\paragraph{Definition 9：CreateContract / LockUtxo}
\begin{itemize}
	\item CreateContract：$\Gamma$ 内のテンプレート $\mathsf{t}_{index}$ と \texttt{init\_params\_bytes}、および $\mathsf{tx}_{id}$・$\mathsf{pk}_{\mathrm{from}}$ を参照し、$\mathsf{c}_{id}$ を生成する $tx$ である。
	      Contract Transaction 共通ヘッダに従い、$\mathsf{aux}$ の \texttt{tx\_type} は \texttt{CREATE} とする。
	\item LockUtxo：通常 $u$ を消費し、$u^\star$ を出力する。
	      LockUtxo はインスタンス化された $\mathsf{c}_{id}$ に対して送信され、$\mathsf{stateTag}$ を初期状態に持つ $u^\star$ を生成する。
	      出力には $(\mathsf{c}_{id}, \mathsf{stateTag}=s_{\mathrm{init}})$ が付与される。
	      ここで $s_{\mathrm{init}} \in \mathsf{StateSet}_\tau$ はテンプレートが定める初期状態である。
	      Contract Transaction 共通ヘッダに従い、$\mathsf{aux}$ の \texttt{tx\_type} は \texttt{LOCK} とする。
\end{itemize}

\paragraph{Definition 10：Release / Transition}
$u^\star$ を入力として消費する $tx$ を contract transition $tx$ と呼ぶ。
$u^\star$ を消費する $tx$ は必ず Contract Transaction として検証されなければならず、\texttt{tx\_type} が既知集合に含まれない場合は（少なくとも $u^\star$ を入力に含む限り）$\mathsf{Invalid}$ とする。
特に ExecuteContract は contract transition $tx$ の一種であり、$\mathsf{c}_{id}$ と関数 index（$\mathsf{LogicIndex}$）$\ell$、および引数 $\mathsf{args}$ をフィールドとして持つ（例：$\mathsf{aux}$ 内に格納）。
Contract Transaction 共通ヘッダに従い、$\mathsf{aux}$ の \texttt{tx\_type} は \texttt{EXECUTE} とし、\texttt{state\_ref} と \texttt{call\_data\_bytes}（canonical）を含む。
ExecuteContract は対応する $u^\star$ を入力として消費し、その消費により一回性を担保する（$\mathsf{aux}$ だけでの担保は不可）。
さらに、$\mathsf{c}_{id}$ から対応する $u^\star$ を取得し、$(\ell, \mathsf{args})$ から $\mathsf{modifier}_\ell$ と $\mathsf{validation}_\ell$ を取得して双方の検証を行い、通過した場合に $u^\star$ の $\mathsf{stateTag}$ を更新する。
つまり、ExecuteContract $tx$ は $u^\star$ の状態遷移を命令するものであり、テンプレートはその検証機として働く。
ここで $\ell$ はテンプレートが定める $\mathsf{LogicIndex}$ であり、遷移ラベルとして用いる。
型注釈として、
\begin{equation}
	\mathsf{Pred}_{\tau,\ell} : \Sigma \times \mathsf{Tx} \times \mathsf{CID} \to \{\mathsf{true}, \mathsf{false}\}
\end{equation}
\begin{equation}
	\mathsf{TransSpec}_{\tau,\ell} : \Sigma \times \mathsf{CID} \to \mathcal{P}(\mathsf{Out})
\end{equation}
を用いる。
ここで $\mathsf{Tx}$ は $tx$ の集合、$\mathsf{CID}$ はコントラクト識別子集合、$\mathsf{Out}$ は出力 $u$ 列の集合である。
$\mathsf{Pred}$ は $\Sigma$ と $tx$ の $\mathsf{in}/\mathsf{out}/\mathsf{aux}$ を参照して決定的に真偽が定まる述語である。
時間条件 $\operatorname{after}(d), \operatorname{after}(t)$ は $\mathsf{chain\_time} \ge d$ の形で評価し、$d,t$ は Unix epoch seconds の整数（例：u64）として扱う。
$\mathsf{chain\_time}$ はブロックヘッダ時刻ではなく、合意的時刻（例：median time past, MTP）を用いる。
このとき、次を満たすときに限り $tx$ は admissible とする。
\begin{enumerate}
	\item[(i)] 述語の成立：$\mathsf{Pred}_{\tau,\ell}(\Sigma, tx, \mathsf{c}_{id}) = \mathsf{true}$
	\item[(ii)] 出力の一致：$\mathsf{out}$ が $\mathsf{TransSpec}_{\tau,\ell}$ に一致（受益者・配分・ロック継続・次状態タグ等）
\end{enumerate}

\paragraph{Definition 11：FinalizeContract / Timeout}
テンプレートは「誰でも起動可能な確定遷移」を持ち得る。
たとえば、期限経過により自動的に決着する遷移（$\operatorname{after}(d), \operatorname{after}(t)$）を $\ell_{\mathrm{final}}$ として与え、上の admissibility で検証可能にする。
これにより資金が永久拘束されないこと（liveness）を仕様として扱える（RQ3）。

\subsection{不変条件（Invariants）と要件 R1--R4 への対応}
本稿は、資金拘束・解放を「人間の裁量」ではなく制度（検証規則）として固定し、失敗遷移（misappropriation）を排除／拘束することを狙う。
以下、テンプレート型スマートコントラクトが満たすべき不変条件を定義し、R1--R4 と対応付ける（RQ3）。

\paragraph{Invariant S（Safety）}
任意の admissible $tx$ に対し、価値保存と受益者制約が破れない。
\begin{itemize}
	\item 価値が任意に増えない（base rule）
	\item テンプレートが許さない受益者への移転が生じない（$\mathsf{TransSpec}$ により拘束）
\end{itemize}

\paragraph{Invariant A（Authority Safety）}
Operator が単独で資金を不正流用できる遷移 $F$ が admissible にならない（R1）。
典型には、署名条件・共同署名・期限付き自動遷移などで「単独での解放」を制度的に排除する。

\paragraph{Invariant L（Liveness）}
テンプレートが定める前提（期限・当事者署名など）が満たされれば、Locked 状態が永久に残留しない（デッドロックしない）。
これは「FinalizeContract/Timeout が誰でも起動可能」等で与えられる（RQ3）。

\paragraph{Invariant B（Bounded Auditability）}
各テンプレート $\tau$ について、検証者が点検すべきロジックは $\mathsf{Bound}$ により上限付けられ、インスタンス化により複雑性が無制限に増えない（R3）。

\paragraph{要件対応（まとめ）}
\begin{itemize}
	\item R1：$F$ を admissibility から排除（Authority Safety）
	\item R2：$\mathsf{Pred}$ と $\mathsf{TransSpec}$ による決定的 admissibility
	\item R3：テンプレートによる監査上限
	\item R4：状態は基本的に UTXO を局所状態として扱う。
	      共有される状態語彙は $\mathsf{stateTag}$ に限定し、参照情報は $\Gamma$ を不変として保持
\end{itemize}

\subsection{次章への接続（テンプレート具体化）}
次章では、本章の一般形式を、焦点ケース（IOM-CE）に対応する具体テンプレート（$\mathrm{deposit}/\mathrm{release}/\mathrm{refund}$）へ具体化し、状態ラベル、引数、署名条件、期限条件、出力仕様を $\mathsf{TransSpec}$ として与える。
